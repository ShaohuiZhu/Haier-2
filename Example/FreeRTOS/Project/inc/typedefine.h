/***********************************************************************/
/*                                                                     */
/*  FILE        :typedefine.h                                          */
/*  DATE        :Fri, Mar 27, 2009                                     */
/*  DESCRIPTION :define scalar types.                                  */
/*  CPU GROUP   :64                                                    */
/*                                                                     */
/*  This file is generated by Renesas Project Generator (Ver.4.12).    */
/*                                                                     */
/***********************************************************************/
#ifndef __TYPEDEF__
#define __TYPEDEF__

typedef signed int  s32;
typedef signed short s16;
typedef signed char  s8;

typedef signed int  const sc32; 			  /* Read Only */
typedef signed short const sc16; 		 	  /* Read Only */
typedef signed char  const sc8;  		 	  /* Read Only */

typedef volatile signed int  vs32;
typedef volatile signed short vs16;
typedef volatile signed char  vs8;

typedef volatile signed int  const vsc32;    /* Read Only */
typedef volatile signed short const vsc16;    /* Read Only */
typedef volatile signed char  const vsc8;     /* Read Only */

typedef unsigned int  u32;
typedef unsigned short u16;
typedef unsigned char  u8;

typedef unsigned int  const uc32;			  /* Read Only */
typedef unsigned short const uc16;			  /* Read Only */
typedef unsigned char  const uc8; 			  /* Read Only */

typedef volatile unsigned int  vu32;
typedef volatile unsigned short vu16;
typedef volatile unsigned char  vu8;

typedef volatile unsigned int  const vuc32;  /* Read Only */
typedef volatile unsigned short const vuc16;  /* Read Only */
typedef volatile unsigned char  const vuc8;   /* Read Only */

typedef union	{                             /* signed 32bit RAM */
    struct  {
        u32    _0:1;  
        u32    _1:1;  
        u32    _2:1;  
        u32    _3:1;  
        u32    _4:1;  
        u32    _5:1;  
        u32    _6:1;  
        u32    _7:1;  
        u32    _8:1;  
        u32    _9:1;  
        u32    _10:1; 
        u32    _11:1; 
        u32    _12:1; 
        u32    _13:1; 
        u32    _14:1; 
        u32    _15:1; 
        u32    _16:1; 
        u32    _17:1; 
        u32    _18:1; 
        u32    _19:1; 
        u32    _20:1; 
        u32    _21:1; 
        u32    _22:1; 
        u32    _23:1; 
        u32    _24:1; 
        u32    _25:1; 
        u32    _26:1; 
        u32    _27:1; 
        u32    _28:1; 
        u32    _29:1; 
        u32    _30:1; 
        u32    _31:1; 
    } bit;
	struct	{
		u16	low;                              /* 16bit access L */
		s16	high;                             /* 16bit access H */
	}hword; 
	s32 s32;                                  /* 32bit access */
} sword;
typedef union	{                             /* unsigned 32bit RAM */
    struct  {
        u32    _0:1;  
        u32    _1:1;  
        u32    _2:1;  
        u32    _3:1;  
        u32    _4:1;  
        u32    _5:1;  
        u32    _6:1;  
        u32    _7:1;  
        u32    _8:1;  
        u32    _9:1;  
        u32    _10:1; 
        u32    _11:1; 
        u32    _12:1; 
        u32    _13:1; 
        u32    _14:1; 
        u32    _15:1; 
        u32    _16:1; 
        u32    _17:1; 
        u32    _18:1; 
        u32    _19:1; 
        u32    _20:1; 
        u32    _21:1; 
        u32    _22:1; 
        u32    _23:1; 
        u32    _24:1; 
        u32    _25:1; 
        u32    _26:1; 
        u32    _27:1; 
        u32    _28:1; 
        u32    _29:1; 
        u32    _30:1; 
        u32    _31:1; 
    } bit;
	struct	{
		u16	low;                              /* 16bit access L */
		u16	high;                             /* 16bit access H */
	}hword;
	u32 u32;                                  /* 32bit access */
} uword;
typedef union	{                             /* signed 16bit RAM */
    struct  {
        u16    _0:1;  
        u16    _1:1;  
        u16    _2:1;  
        u16    _3:1;  
        u16    _4:1;  
        u16    _5:1;  
        u16    _6:1;  
        u16    _7:1;  
        u16    _8:1;  
        u16    _9:1;  
        u16    _10:1; 
        u16    _11:1; 
        u16    _12:1; 
        u16    _13:1; 
        u16    _14:1; 
        u16    _15:1; 
    } bit;
	struct	{
		u8	low;                              /* 16bit access L */
		u8	high;                             /* 16bit access H */
	} byte;
    u16    u16;
} uhword;

typedef union {
    struct{
        u8 _0:1;
        u8 _1:1;
        u8 _2:1;
        u8 _3:1;
        u8 _4:1;
        u8 _5:1;
        u8 _6:1;
        u8 _7:1;
    } bit;
	u8 u8;
} ubyte;

typedef enum {FALSE = 0,false = 0, TRUE = !FALSE, true = TRUE} bool;

//typedef enum {RESET = 0, SET = !RESET} FlagStatus, ITStatus;

//typedef enum {DISABLE = 0, ENABLE = !DISABLE} FunctionalState;
//#define IS_FUNCTIONAL_STATE(STATE) (((STATE) == DISABLE) || ((STATE) == ENABLE))

//typedef enum {ERROR = 0, SUCCESS = !ERROR} ErrorStatus;

//#define NULL (0)

#define U8_MAX     ((u8)255)
#define S8_MAX     ((s8)127)
#define S8_MIN     ((s8)-128)
#define U16_MAX    ((u16)65535u)
#define S16_MAX    ((s16)32767)
#define S16_MIN    ((s16)-32768)
#define U32_MAX    ((u32)4294967295uL)
#define S32_MAX    ((s32)2147483647)
#define S32_MIN    ((s32)-2147483648)

/* Exported constants --------------------------------------------------------*/
/* Exported macro ------------------------------------------------------------*/
/* Exported functions --------------------------------------------------------*/

/* myself define type--------------------------------------------------------*/

//#define MCU32
#ifdef MCU32
  #define LocalUI u32
  #define LocalSI s32
#else
  #define LocalUI u16
  #define LocalSI s16
#endif
//注意LocalUI、LocalSI的变量类型，因为没有使用8bit MCU，所以只定义了16和32bit，
//使用Local的变量最大值不要超过u16/s16的最大值
//若定义LocalUI u8、LocalSI u16，小心数据类型的最大值，防止溢出
//------原RENESAS---------------------------------------------
typedef signed char _SBYTE;
typedef unsigned char _UBYTE;
typedef signed short _SWORD;
typedef unsigned short _UWORD;
typedef signed int _SINT;
typedef unsigned int _UINT;
typedef signed long _SDWORD;
typedef unsigned long _UDWORD;
typedef signed long long _SQDWORD;
typedef unsigned long long _UQDWORD;

#define POINTER_SHIFT(type,p) (*((type)p))
//#define FAR far
#define RENESAS

//与OOPC相关的宏 基本定义
//类和接口定义宏
#ifndef RENESAS
#define CLASS(type) \
typedef struct T##type T##type; \
struct T##type
#define CLASS_TYPEDEF(type) 
#else
#define CLASS(type) struct T##type
#define CLASS_TYPEDEF(type) typedef struct T##type T##type
#endif
//#define INTERFACE(type) CLASS(type)
#define INTERFACE(type) CLASS(type)
#define INTERFACE_TYPEDEF(type) CLASS_TYPEDEF(type)

#define IMPLEMENTS(type) FAR struct T##type* type
//在类中实现接口，或父类，声明一个变量
#define EXTENDS(type) struct T##type type
//在类中实现多个接口，或父类，或父类对象不是子类中定义的首对象时，获取接口/父对象指针
//(1)当一个类只继承一个父类或接口时，这个父类或接口宜放在这个类定义的第一个变
//   量位置, 这时候直接使用C语言的类型转换就行了
//(2)当一个类继承多个父类或接口时，这个父类或接口可以放在这个类定义的任意位置，
//   但必须在这些父类（接口）定义中加一个变量定义void *implementor。在子类的初
//   始化中使用DERIVE_SETTING宏初始化implementor变量。子类到父类的转换用GetIn-
//   terface或者GetSuperclass宏，父类到子类的转化用GetSubclass宏( 如果不使用子
//   类到父类的转换，可以不声明implementor)。
#define getInterface(pObj,interface) (&((pObj)->interface))
#define GetSuperclass(pObj,parent) (&((pObj)->parent))
//由接口/父对象指针获取子对象指针，接口/父类定义必须包含void *implementor
#define getSubclass(pObj) (pObj->implementor)

//在头文件中声明类的初始化函数
//#define DECLARE_INITIALIZE(type) \
//extern type* New##type(); \
//extern void type##_Init(struct type *)
//类的初始化函数声明和实现在同一个文件中，且不在其他文件中调用时用下面的宏
//(1)不带参数的初始化函数声明
#define DECLARE_INITIALIZE(type) \
void type##_Init(struct T##type *)

//(2)带1个参数的初始化函数声明
#define DECLARE_INITIALIZE1(type,type1) \
void type##_Init(struct T##type *,type1)

//(3)带2个参数的初始化函数声明
#define DECLARE_INITIALIZE2(type,type1,type2) \
void type##_Init(struct T##type *,type1,type2)

//(4)带3个参数的初始化函数声明
#define DECLARE_INITIALIZE3(type,type1,type2,type3) \
void type##_Init(struct T##type *,type1,type2,type3)

//(4)带4个参数的初始化函数声明
#define DECLARE_INITIALIZE4(type,type1,type2,type3,type4) \
void type##_Init(struct T##type *,type1,type2,type3,type4)

//创建一个type类型的对象var，并做初始化
#define create(type,var) \
T##type var; \
type##_Init(&var)

//类的初始化函数 ――开始
//用NewType定义的变量不再释放RAM空间，适用于全局或模块变量,如：
//UserType *pObj=NewUserType();
//ParentClass *p=(ParentClass*)pObj; /* 可以将子类对象转换为父类或接口对象 */
//局部变量这样定义：
//UserType obj;         /* 在栈空间分配存储单元 */
//InitUserType(&obj);   /* 对变量初始化 */
//ParentClass *p=(ParentClass*)&Obj; /* 可以将子类对象转换为父类或接口对象 */
//(1)不带参数的初始化函数
#define BEGIN_INITIALIZE(type) \
void type##_Init(struct T##type *THIS){ 
	
//(2)带1个参数的初始化函数，形式参数名称是PARAM1
#define BEGIN_INITIALIZE1(type,type1) \
void type##_Init(struct T##type *THIS,type1 PARAM1){ 
	
//(3)带2个参数的初始化函数，在初始化函数中引用形式参数时，其名称依次是PARAM1，PARAM2
#define BEGIN_INITIALIZE2(type,type1,type2) \
void type##_Init(struct T##type *THIS,type1 PARAM1,type2 PARAM2){ 
	
//(4)带3个参数的初始化函数，在初始化函数中引用形式参数时，其名称依次是PARAM1，PARAM2，PARAM3
#define BEGIN_INITIALIZE3(type,type1,type2,type3) \
void type##_Init(struct T##type *THIS,type1 PARAM1,type2 PARAM2,type3 PARAM3){ 
	
//(5)带4个参数的初始化函数，在初始化函数中引用形式参数时，其名称依次是PARAM1，PARAM2，PARAM3，PARAM4
#define BEGIN_INITIALIZE4(type,type1,type2,type3,type4) \
void type##_Init(struct T##type *THIS,type1 PARAM1,type2 PARAM2,type3 PARAM3,type4 PARAM4){ 
	
//类的Init函数 ――变量初始化
#define VARIABLE_SETTING(var_name,value) THIS->var_name=value
#define INTERFACE_SETTING(type,array) THIS->type=(FAR T##type*)(&array)
//类的Init函数 ――函数指针初始化
#define FUNCTION_SETTING(func_pointer,fun_name) THIS->func_pointer=fun_name
//类的Init函数 ――调用父类Create函数
#define SUPER(super_class)  Init##super_class(&(THIS->super_class))
//类的Init函数 ――父类变量或函数指针初始化
#define SUPER_SETTING(super_class,var,val) THIS->super_class.var=val
//类的Init函数 ――在类中实现多个接口或父类，声初始化子对象指针
#define DERIVE_SETTING(super_class) THIS->super_class.implementor=THIS
//类的Init函数 ――结束
#define END_INITIALIZE }

#endif